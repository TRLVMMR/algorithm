 import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;
 
public class AhoCorasickAutomation {
    /*本示例中的AC自动机只处理英文类型的字符串，所以数组的长度是128*/
    private static final int ASCII = 128;
     
    /*AC自动机的根结点，根结点不存储任何字符信息*/
    private Node root;
     
    /*待查找的目标字符串集合*/
    private List<String> target;
     
    /*表示在文本字符串中查找的结果，key表示目标字符串， value表示目标字符串在文本串出现的位置, 可能有多个位置，所以用list*/
    private HashMap<String, List<Integer>> result;
     
    /*内部静态类，用于表示AC自动机的每个结点，在每个结点中我们并没有存储该结点对应的字符*/
    private static class Node{
         
        /*如果该结点是一个终点，则把目标字符串赋值给str，若不是终点，则为null*/
        String str;
         
        /*ASCII == 128, 所以这里相当于128叉树*/
        Node[] table = new Node[ASCII];
         
        Node fail;
         
        public boolean isWord(){
            return str != null;
        }
         
    }
     
    /*target表示待查找的目标字符串集合*/
    public AhoCorasickAutomation(List<String> target){
        root = new Node();
        this.target = target;
        buildTrieTree();
        build_AC_FromTrie();
    }
     
    /*由目标字符串构建Trie树*/
    private void buildTrieTree(){
        for(String targetStr : target){
            Node curr = root;
            //把字符串拆分成字符,存到Trie里
            for(int i = 0; i < targetStr.length(); i++){
                char ch = targetStr.charAt(i);
                if(curr.table[ch] == null){
                    curr.table[ch] = new Node();
                }
                curr = curr.table[ch];
            }
            /*将每个目标字符串的最后一个字符对应的结点变成终点*/
            curr.str = targetStr;
        }
    }
     
    /*由Trie树构建AC自动机，本质是一个自动机，相当于构建KMP算法的next数组*/
    private void build_AC_FromTrie(){
        /*某个节点fail = if (this.字符 == 父亲fail指针.child.字符), 一直到找到位置，或者root*/

        LinkedList<Node> queue = new LinkedList<Node>();
        /*单独处理root的所有孩子结点赋值为root*/
        for(Node x : root.table){
            if(x != null){
                /*根结点的所有孩子结点的fail都指向根结点*/
                x.fail = root;
                queue.addLast(x);/*所有根结点的孩子结点入列*/
            }
        }
         
        while(!queue.isEmpty()){
            /*确定出列结点的所有孩子结点的fail的指向*/
            Node p = queue.removeFirst();
            //遍历节点的128个字符， 目的是，让p.chind[i].fail指向相应位置， 即孩子的fail指针指向
            for(int i = 0; i < p.table.length; i++){
                //如果存在相应字符的孩子，入列， table[i]就是节点存放的字符
                if(p.table[i] != null){
                    queue.addLast(p.table[i]);
                    /*从p.fail开始找起*/
                    Node failTo = p.fail;
                    while(true){
                        /*说明找到了根结点还没有找到*/
                        if(failTo == null){
                            p.table[i].fail = root;
                            break;
                        }
                         
                        /*说明有公共前缀： fail指针里有跟它相同的字符*/
                        if(failTo.table[i] != null){
                            p.table[i].fail = failTo.table[i];
                            break;
                        }else{/*继续向上寻找*/
                            failTo = failTo.fail;
                        }
                    }
                }
            }
        }
    }
     
    /*在文本串中查找所有的目标字符串*/
    public HashMap<String, List<Integer>> find(String text){
        /*创建一个表示存储结果的对象*/
        result = new HashMap<String, List<Integer>>();
        for(String s : target){
            result.put(s, new LinkedList<Integer>());
        }
         
        Node curr = root;
        int i = 0;
        while(i < text.length()){
            /*文本串中的字符*/
            char ch = text.charAt(i);
             
            /*文本串中的字符和AC自动机中的字符进行比较*/
            if(curr.table[ch] != null){
                /*若相等，自动机进入下一状态*/
                curr = curr.table[ch];
                 
                //若找到了一个目标串，将其位置加入结果集
                if(curr.isWord()){
                	//result.get获取value，是个list, list.add加入出现的位置
                    result.get(curr.str).add(i - curr.str.length()+1);
                }
                 
                /*这里很容易被忽视，因为一个目标串的中间某部分字符串可能正好包含另一个目标字符串，
                 * 即使当前结点不表示一个目标字符串的终点，但到当前结点为止可能恰好包含了一个字符串*/
                if(curr.fail != null && curr.fail.isWord()){
                    result.get(curr.fail.str).add(i - curr.fail.str.length()+1);
                }
                 
                /*索引自增，指向下一个文本串中的字符*/
                i++;
            }else{
                /*若不等，找到下一个应该比较的状态*/
                curr = curr.fail;
                 
                /*到根结点还未找到，说明文本串中以ch作为结束的字符片段不是任何目标字符串的前缀，
                 * 状态机重置，比较下一个字符*/
                if(curr == null){
                    curr = root;
                    i++;
                }
            }
        }
        return result;
    }
     
     
    public static void main(String[] args){
        List<String> target = new ArrayList<String>();
        target.add("abcdef");
        target.add("abhab");
        target.add("bcd");
        target.add("cde");
        target.add("cdfkcdf");
         
        String text = "bcabcdebcedfabcdefababkabhabk";
         
        AhoCorasickAutomation aca = new AhoCorasickAutomation(target);
        HashMap<String, List<Integer>> result = aca.find(text);
         
        System.out.println(text);
        for(Entry<String, List<Integer>> entry : result.entrySet()){
            System.out.println(entry.getKey()+" : " + entry.getValue());
        }
         
    }
}